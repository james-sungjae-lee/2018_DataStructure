// *********************************************************
// * Name : 이성재
// * Student ID : 20132651
// * Program ID : Hw1_miro.cpp
// * Description: 2차원 배열 형태의 미로를 입력받은 후, 시작점부터 도착점까지
// * 도달하기 위한 시도와 정답을 출력하는 코드입니다.
// * Variables
// * maze[][]:미로의 형태를 의미하는 2차원 배열 변수
// * mark[][]:미로를 찾기 위해 지나간 길을 표시하는 2차원 배열 변수
// * struct offsets: 미로를 찾기 위해 시작점을 이동시키기 위한 구조체
// * offsets move[].vert / move[].horiz: 수평, 수직 방향으로 시작점을 이동시키기 위한 구조체 변수
// * exitRow / exitCol: 미로가 끝나는 위치의 좌표. 여기서는 4,4 가 끝나는 점.
// * d: 현재 시작점이 나아갈 방향. move 의 [] 좌표와 연동됨. 처음은 동쪽인 2로 초기화.
// * i, j: 현재 시작점이 존재하는 좌표 위치. 처음은 1, 1로 초기화.
// * found: 시작점이 도착점에 도달했는지를 판별하는 불리안 변수. 처음에는 false, 도착하면 true
// * g, h: 시작점에서 본 이동 방향의 좌표. 만약 이동 가능하고(maze값이 0) 마크가 되어있지 않으면(mark값이 0)
// * 그 방향으로 이동하여 mark 값을 1로 바꾼다.
// * 중간의 for 문에서의 i, j 지역변수: mark 값을 출력하기 위한 변수.
// **********************************************************

#include "stack.hpp"

int mazeSolve();

int maze[14][17] = {{1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1},
                    {1,0,1,0,0,0,1,1,0,0,0,1,1,1,1,1,1},
                    {1,1,0,0,0,1,1,0,1,1,1,0,0,1,1,1,1},
                    {1,0,0,1,0,0,0,0,1,1,1,1,0,0,1,1,1},
                    {1,1,1,0,1,1,1,1,0,1,1,0,1,1,0,0,1},
                    {1,1,1,0,1,0,0,1,0,1,1,1,1,1,1,1,1},
                    {1,0,0,1,1,0,1,1,1,0,1,0,0,1,0,1,1},
                    {1,0,0,1,1,0,1,1,1,0,1,0,0,1,0,1,1},
                    {1,0,1,1,1,1,0,0,1,1,1,1,1,1,1,1,1},
                    {1,0,0,1,1,0,1,1,0,1,1,1,1,1,0,1,1},
                    {1,1,1,0,0,0,1,1,0,1,1,0,0,0,0,0,1},
                    {1,0,0,1,1,1,1,1,0,0,0,1,1,1,1,0,1},
                    {1,0,1,0,0,1,1,1,1,1,0,1,1,1,1,0,1},
                    {1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1}};


                 // {{1,1,1,1,1,1},
                 // {1,0,1,1,1,1},
                 // {1,0,0,0,0,1},
                 // {1,1,0,1,1,1},
                 // {1,0,1,0,0,1},
                 // {1,1,1,1,1,1}};


int mark[14][17];


// {{0,0,0,0,0,0}, {0,0,0,0,0,0}, {0,0,0,0,0,0}, {0,0,0,0,0,0}, {0,0,0,0,0,0}, {0,0,0,0,0,0}};

// **********************************************************
// * function: int main
// * description: 메인 함수입니다. mazeSolve 함수를 실행시킵니다.
// **********************************************************

int main(int argc, char const *argv[]) {
  mazeSolve();
  return 0;
}

// **********************************************************
// * function: int mazeSolve
// * description: 스택을 이용해 미로를 해결하는 함수입니다.
// * variables : 위에서 모두 설명함.
// **********************************************************

int mazeSolve(){

  for (size_t i = 0; i < 14; i++) {
    for (size_t j = 0; j < 17; j++) {
      mark[i][j] = 0;
    }
  }

  // 우선 이동을 위한 move 구조체를 정의합니다. 상하좌우에 따라 +- 1, 0의 값을 가집니다.
  // 좌표와 같이 중심을 기준으로 우측과 상단은 +1, 좌측과 하단은 -1 입니다. 이동하지 않으면 0.
  // 북쪽을 기준으로 시계방향으로 0 부터 7까지의 위치값을 할당합니다.
  typedef struct {short int vert; short int horiz;}offsets;
  offsets move[8];
  move[0].vert = -1; move[0].horiz = 0; //n
  move[1].vert = -1; move[1].horiz = 1; //ne
  move[2].vert = 0; move[2].horiz = 1; //e
  move[3].vert = 1; move[3].horiz = 1; //se
  move[4].vert = 1; move[4].horiz = 0; //s
  move[5].vert = 1; move[5].horiz = -1; //sw
  move[6].vert = 0; move[6].horiz = -1; //w
  move[7].vert = -1; move[7].horiz = -1; //nw

  //초기 위치인 1,1 을 지나갔음을 mark 에 표시합니다.
  mark[1][1] = 1;

  //종료 위치인 exit 좌표를 4,4 로 정의합니다.
  int exitRow = 13;
  int exitCol = 16;

  //스택에 입구 좌표 저장합니다.
  push(1, 1, 2);

  // 현재 위치좌표 i, j 와 이동 좌표 d 를 정의합니다.
  int i, j, d;

  bool found = false; // 처음에는 길찾기 실패상태입니다.

  //스택이 비어있지 않으면서 아직 길을 못찾았다면 다음을 반복합니다.
  while ((!isEmpty()) && (!found)) {

    // i, j, dir 의 값을 stack 에서 pop 으로 뽑아내 온 값을 저장합니다.
    //이는 지금까지 온 길을 되돌아 가는 작업입니다.
    i = pop0();
    j = pop1();
    d = pop2();
    topMinus();

    // 현재 이동이 가능한 상태라면, 다음을 반복합니다.
    while ((d < 8) && (!found)) {

      //이동 예정인 위치인 g, h의 좌표를 할당합니다.
      int g = i + move[d].vert;
      int h = j + move[d].horiz;

      //만약 g, h 좌표가 도착점이라면, "도착!" 출력과 함께
      //지금까지의 경로인 mark 를 출력합니다.
      if ((g == exitRow)&&(h == exitCol)) {
        found = true;
        std::cout << "도착!" << '\n';
        mark[g][h] = 1;
        for (size_t i = 0; i < 14; i++) {
          for (size_t j = 0; j < 17; j++) {
            std::cout << mark[i][j] << " ";
          }
          std::cout << '\n';
        }
        return 0;
      }

      // 만약 미로에서 g, h좌표가 이동 가능하며, 아직 간 적 없다면 다음을 실행합니다.
      if ((!maze[g][h])&&(!mark[g][h])) {

        // 우선 mark 에 지나갔다는 표시를 합니다.
        mark[g][h] = 1;

        //현재 위치를 스택에 저장합니다.
        push(i, j, d + 1);

        //현재 위치인 i, j를 이동 위치인 g, h로 바꿉니다.
        i = g;
        j = h;

        //이동 방향은 동쪽인 2번으로 초기화합니다.
        d = 0;
      }else{

        //만약 위의 상황이 아니라면, 다른 경로를 찾기 위해
        //이동 변수 d 를 1 증가시킵니다.
        d++;
      }
    }
  }
  std::cout << '\n';
  for (size_t i = 0; i < 14; i++) {
    for (size_t j = 0; j < 17; j++) {
      std::cout << mark[i][j] << " ";
    }
    std::cout << '\n';
  }
  //도착점을 찾을 수 없다면 다음 문장을 출력합니다.
  std::cout << "no path in maze" << '\n';

  return 0;
}
