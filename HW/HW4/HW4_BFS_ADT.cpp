// ******************************************************************************************************************
// * Name : 이성재
// * Student ID : 20132651
// * Program ID : HW4_BFS_ADT.cpp
// * description : HW4_BFS.hpp에서 정의한 프로토타입 함수들의 구현입니다.
// ********************************************************************************************************************

#include "HW4_BFS.hpp"

// ********************************************************************************************************************
// * function : void Graph::matrixToList()
// * description : 최초로 입력된 매트릭스 형태의 그래프 데이터를 링크드리스트 형태로 변환하는 함수입니다.
// *
// * Variable
// * : Node *move : 링크드리스트를 이동하며 현재 노드와 다음 노드를 이어주는 노드 포인터입니다.
// * : Node *headNode : 노드 포인터들의 집합인 graph에서, 실제로 저장되는 가장 첫 번째 헤드 노드를 저장합니다.
// * : Node *temp : 매트릭스를 읽어온 결과 노드를 생성해야 한다면, 이 temp 노드를 새로 생성하여 데이터를 저장합니다.
// *                temp 노드는 graph 리스트 배열에 헤드 노드로 저장되거나, 헤드 노드의 다음 노드들중 하나로 연결됩니다.
// * : Node *grpah[MAX] : 각 링크드 리스트의 헤드 노드를 차례로 저장하는 graph 배열이 이 함수에서 사용됩니다.
// *
// * Algorithm description
// * : 1. 먼저 헤드 노드를 가리키는 포인터 headNode를 헤드 노드를 저장하는 graph 배열의 인자와 같게 설정합니다.
// * :    이를 통해 첫 번째 들어오는 헤드 노드는 graph[i] 에 저장되고, 그렇지 않은 것은 헤드 노드의 next 로 저장되는
// * :    조건문을 작동시킬 수 있게 됩니다.
// * : 2. 다음으로 matrix 의 i, j 번째 인자가 1인지 아닌지 검사합니다. 만약 1 이라면 조건문을 실행하고, 아니라면 무시합니다.
// * : 3. matrix 의 데이터가 1일 때, i 노드와 j 노드가 연결되었다는 의미이므로 temp 노드를 생성하여, data 를 j로 설정합니다.
// * : 4. 이렇게 생성된 temp 노드를 위에서 말한 것 처럼 graph[i] 혹은 next 노드에 저장합니다. 이 때 move 노드 포인터를 이용하여
// * :    현재의 위치를 저장하거나 다음 노드로 이동하여 저장합니다.
// * : 5. 마지막으로 j 회의 반복문이 종료된 후, 하나의 리스트 생성이 완료되었다면 마지막 노드를 NULL 로 설정합니다. (temp -> next = NULL)
// ********************************************************************************************************************

void Graph::matrixToList() {

  Node *move;
  Node *headNode;
  Node *temp;

  for (size_t i = 0; i < MAX; i++) {
    headNode = graph[i];
    for (size_t j = 0; j < MAX; j++) {
      if (matrix[i][j] == 1) {
        temp = new Node;
        temp->data = j;

        if (graph[i] == headNode) {
          move = temp;
          graph[i] = temp; // graph[i] 의 변경 // headNode != graph[i] 가 됨
        }else{
          move->next = temp;
          move = temp;
        }
      }
    }
    temp->next = NULL;
  }
}

// ********************************************************************************************************************
// * function : void Graph::BFS(int v)
// * description : 시작점 v 인자를 받아와 해당 점부터 넓이 우선 탐색을 시행하고, 결과를 출력하는 함수입니다.
// *
// * Variable
// * : Node *p : 그래프를 순회하며 방문 여부를 체크하고, 방문하지 않았다면 해당 노드를 출력하는 노드 포인터입니다.
// * : int head, rear : 큐 자료구조를 활용해 그래프를 순회하기 위한 큐의 head 와 rear 표시 변수입니다.
// * : int visited[MAX] : 그래프 순회중에 현재의 노드가 출력 된 노드인지 확인하기 위한 배열입니다.
// * : Node *graph[MAX] : 그래프 데이터가 링크드리스트 형태로 담겨있는 노드 포인터 배열입니다. 이곳에서 노드 데이터를 꺼내와 출력합니다.
// * : queue[MAX] : 사용된 노드 데이터를 큐 자료구조 형태로 저장합니다. 한번 지나온 노드 데이터를 다시 되돌아가기 위해 생성합니다.
// *
// * Algorithm description
// * : 1. 가장 먼저 노드 포인터 p, 큐 위치를 체크하기 위한 head, rear 를 정의한 다음 입력된 시작점 v 를 출력 및 visited 체크합니다.
// * : 2. 방문 노드의 순서에 따라 큐에 저장해야 하므로, 가장 먼저 v를 큐에 add 합니다.
// * : 3. 가장 먼저 방문해야 할 리스트는 v 시작점이 헤드 노드인 리스트입니다. 그러므로 v 값을 큐에서 꺼내와, graph[v] 를 시작점으로 반복하는
// * :    for 반복문을 널값이 나타날 때 까지 반복합니다. 이 때 사용되는 변수는 앞에서 정의내린 노드 포인터 p입니다.
// * : 4. 이 때 방문한 적 없는 노드를 만난다면 출력하고, 큐에 저장하고, 방문 여부를 true로 체크합니다.
// * :    이를 구현하기 위해 if 조건문에서 visited 배열을 p->data 값 인덱스로 검색하여 true 여부를 체크합니다.
// * : 5. for 반복문이 종료된 다음, 다음 값을 v 에 저장해 계속 진행합니다.
// ********************************************************************************************************************

void Graph::BFS(int v) {
  std::cout << "\n*** Breath First Search (BFS) ***\n";

  Node *p;
  int head, rear;
  head = -1;
  rear = -1;

  std::cout << "v" << v << "  ";
  visited[v] = true;
  addQueue(&rear, v);
  while (head != rear) {
    v = deleteQueue(&head);
    for(p = graph[v]; p; p = p->next){
      if (!visited[p->data]) {
        addQueue(&rear, p->data);
        visited[p->data] = true;
        std::cout << "v"<< p->data << "  ";
      }
    }
  }
}

// ********************************************************************************************************************
// * function : void Graph::addQueue(int *rear, int data)
// * description : 배열 형태의 queue 자료구조에 int형 자료를 저장하기 위한 함수입니다.
// *
// * Variable
// * : int *rear : 데이터를 삽입할 위치인 큐의 마지막 위치, rear를 포인터 형태로 받아와 값의 변경이 가능합니다.
// * : int data : 큐에 삽입할 int 형 데이터입니다.
// * : int queue[MAX] : 데이터가 삽입될 배열 형태의 queue 자료구조입니다.
// * :
// * Algorithm description
// * : 1. queue 자료구조의 효율성을 위해 원형 큐 형태로 구현합니다. 원형 큐에서 rear는 rear % sizeof Queue = MAX 입니다.
// * : 2. 먼저 rear 값을 하나 증가시킨 다음, queue 배열의 rear 위치에 data 를 넣습니다.
// ********************************************************************************************************************

void Graph::addQueue(int *rear, int data) {
  *rear = (*rear) % MAX;
  queue[++(*rear)] = data;
}

// ********************************************************************************************************************
// * function : int Graph::deleteQueue(int *head)
// * description : 배열 형태의 queue 자료구조에서 head 위치의 값을 삭제하고, 다음 데이터를 반환하는 함수입니다.
// *
// * Variable
// * : int *head : 데이터를 삭제 / 반환할 위치인 큐의 첫번째 위치, head 를 값의 변경이 가능한 포인터 형태로 받아옵니다.
// * : int queue[MAX] : 데이터를 삭제 / 반환할 배열 형태의 queue 자료구조입니다.
// *
// * Algorithm description
// * : 1. 먼저 head 포인터의 실제 값을 1 증가시킵니다. 이를 통해 자연스럽게 해당 데이터가 삭제되고, 다음 데이터를 가리킵니다.
// * : 2. 가리키고 있는 다음 데이터를 queue 에서 찾아, 반환합니다.
// ********************************************************************************************************************

int Graph::deleteQueue(int *head){
  return queue[++(*head) % MAX];
}

// ********************************************************************************************************************
// * function : void Graph::printMatrix()
// * description : 최초에 입력된 매트릭스 형태의 그래프 데이터를 출력하는 함수입니다.
// *
// * Variable
// * : int matrix[MAX][MAX] : 그래프 데이터가 2차원 행렬 형태의 매트릭스로 구현되어 있습니다.
// *
// * Algorithm description
// * : 1. 먼저 해당 매트릭스의 크기만큼 출력 틀을 잡아줍니다. 이 때 for 반복문을 통해 "v" + i 형태로 출력합니다.
// * : 2. 다음으로 2중 for 문을 이용해 매트릭스의 그래프 데이터를 하나씩 출력합니다.
// ********************************************************************************************************************

void Graph::printMatrix(){
  std::cout << "***** Adjacent Matrix *****" << '\n';
  std::cout << "   ";
  for (size_t i = 0; i < MAX; i++) {
    std::cout << "v" << i << " ";
  }
  std::cout << '\n';
  for (size_t i = 0; i < MAX; i++) {
    std::cout << "v" << i << " ";
    for (size_t j = 0; j < MAX; j++) {
      std::cout << matrix[i][j] << "  ";
    }
    std::cout << '\n';
  }
}
